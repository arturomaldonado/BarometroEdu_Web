<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Manejo de datos usando el Barómetro de las Américas</title>

<script src="site_libs/header-attrs-2.18/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">LAPOP_edu</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Preparación
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="instalando.html">Instalando R y RStudio</a>
    </li>
    <li>
      <a href="basica.html">Procedimientos básicos</a>
    </li>
    <li>
      <a href="bases.html">Importación de bases de datos</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Aspectos iniciales
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Manipulacion.html">Manejo de datos</a>
    </li>
    <li>
      <a href="Expansion.html">Factor de expansión</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Describir y graficar
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Descriptivos.html">Descriptivos variables nominales</a>
    </li>
    <li>
      <a href="Descriptivos2.html">Descriptivos variables ordinales</a>
    </li>
    <li>
      <a href="Descriptivos3.html">Descriptivos variables numéricas</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Inferencia básica
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="IC.html">Intervalos de confianza</a>
    </li>
    <li>
      <a href="pruebat.html">Comparación de 2 medias</a>
    </li>
    <li>
      <a href="anova.html">Comparación de varias medias</a>
    </li>
    <li>
      <a href="chi.html">Tablas cruzadas y chi-cuadrado</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Modelamiento
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="correlacion.html">Correlación</a>
    </li>
    <li>
      <a href="regresion1.html">Regresión lineal simple</a>
    </li>
    <li>
      <a href="regresion2.html">Regresión lineal multivariada</a>
    </li>
    <li>
      <a href="logit.html">Regresión logística</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Adicionales
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="mapas.html">Mapas</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Contacto</a>
</li>
<li>
  <a href="https://arturomaldonado.github.io/BarometroEdu_Web_Eng/">English</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Manejo de datos usando el Barómetro de las
Américas</h1>

</div>


<style type="text/css">
.columns {display: flex;}
h1 {color: #3366CC;}
</style>
<div id="introducción" class="section level1">
<h1>Introducción</h1>
<p>En este documento veremos aspectos básicos del manejo de datos, como
la recodificación de una variable, la selección de datos y el cálculo de
una nueva variable. Al final incluímos una nota acerca de los cálculos
estadísticos considerando el efecto de diseño.</p>
</div>
<div id="sobre-la-base-de-datos" class="section level1">
<h1>Sobre la base de datos</h1>
<p>Los datos que vamos a usar deben citarse de la siguiente manera:
Fuente: Barómetro de las Américas por el Proyecto de Opinión Pública de
América Latina (LAPOP), wwww.LapopSurveys.org.</p>
<p>En este documento cargamos una base que se encuentra alojada en el
repositorio “materials_edu” de la cuenta de LAPOP en GitHub. Mediante la
librería <code>rio</code> y el comando <code>import</code> se puede
importar esta base de datos desde este repositorio, usando el siguiente
código. Importamos la base de datos en un objeto “lapop21”. Esta base de
datos tiene extensión .RData y cuando se importa, carga las variables
como del tipo double (“dbl”), que es un tipo de variable numérica que
acepta decimales, a diferencia del tipo integer, “int”, que solo acepta
enteros.</p>
<pre class="r"><code>library(rio)
lapop21 = import(&quot;https://raw.github.com/lapop-central/materials_edu/main/lapop21.RData&quot;)</code></pre>
<p>En este repositorio también se encuentra la base de datos de la ronda
anterior, la que también podemos cargar y llamarla “lapop18”. Es
necesario aclarar que esta base de datos, importada desde un archivo
SPSS, carga las variables como del tipo numéricas (“num”) que para fines
prácticos es igual al formato doble (“dbl”).</p>
<pre class="r"><code>lapop18 = import(&quot;https://raw.github.com/lapop-central/materials_edu/main/LAPOP_AB_Merge_2018_v1.0.sav&quot;)</code></pre>
</div>
<div id="recodificación-de-una-variable" class="section level1">
<h1>Recodificación de una variable</h1>
<p>En esta sección usaremos el reporte “El Pulso de la Democracia”, con
los resultados de la última ronda 2021 del Barómetro de las Américas,
disponible <a
href="https://www.vanderbilt.edu/lapop/ab2021/2021_LAPOP_AmericasBarometer_Pulse_of_Democracy.pdf">aquí</a>.
Este reporte presenta los resultados acerca del apoyo a la democracia en
las Américas. Estos resultados se basan en la variable ING4 de la base
de datos. Esta variable está fraseada de la siguiente manera:</p>
<p><strong>ING4.</strong> <em>Cambiando de nuevo de tema, puede que la
democracia tenga problemas, pero es mejor que cualquier otra forma de
gobierno. ¿Hasta qué punto está de acuerdo o en desacuerdo con esta
frase?</em></p>
<p>Esta variable está medida en una escala del 1 a 7, donde 1 significa
“muy en desacuerdo” y 7 significa “muy de acuerdo”. Luego, los valores
entre 5 a 7 son recodificados como apoyo a la democracia. Para ver la
distribución de respuestas a esta variable, podemos usar el comando
<code>table</code>.</p>
<pre class="r"><code>table(lapop21$ing4)</code></pre>
<pre><code>## 
##     1     2     3     4     5     6     7 
##  5704  2567  4980  8177 13886  8390 16759</code></pre>
<p>De esta manera calculamos las observaciones (frecuencias absolutas)
por cada valor de la variable. Para calcular el porcentaje de personas
que apoya a la democracia tenemos que recodificar esta variable y crear
una nueva. Es decir, la variable original ING4, en una escala de 1-7, la
recodificamos en una nueva variable, siguiendo la siguiente regla:</p>
<ol style="list-style-type: decimal">
<li>Valores entre 1-4 de ING4 se transforman en 0 en una nueva variable
ing4r</li>
<li>Valores entre 5-7 de ING4 se transformen en 1 en una nueva variable
ing4r</li>
</ol>
<p>Un ejemplo de cómo se presentan estos datos recodificados en el
reporte se puede ver en el Gráfico 1.1. Este muestra el porcentaje de
ciudadanos que apoya a la democracia por país. Es decir, se muestra el
porcentaje de entrevistados que respondieron entre 5 y 7 a la pregunta
ING4 en cada país. De acuerdo a la recodificación planteada, este
gráfico representaría el porcentaje de entrevistados que registra un 1
en la variable recodificada.</p>
<p><img src="Grafico1.1.png" /></p>
<p>En el informe El Pulso de la Democracia de la ronda 2018/19,
disponible <a
href="https://www.vanderbilt.edu/lapop/ab2018/2018-19_AmericasBarometer_Regional_Report_Spanish_W_03.27.20.pdf">aquí</a>,
también se presenta un gráfico similar, usando la misma variable y la
misma regla de recodificacíon.</p>
<p><img src="Graf1.2.png" width="350" /></p>
<p>Para recodificar una variable en R hay varias formas. Una de las
formas más eficientes de hacerlo es usando el comando
<code>recode</code> del paquete <code>car</code>. El paquete
<code>dplyr</code> tiene un comando <code>recode</code> que puede
confundir a R. Para evitar confusiones usaremos la sintaxis
<code>car::recode</code> para la recodificación, es decir para
especificar que se use el comando <code>recode</code>del paquete
<code>car</code> y no de otro. Guardamos la variable recodificada como
“lapop21$ing4rec (es decir, creamos una nueva variable o vector en el
dataframe). Luego, usamos el comando <code>table</code> para describir
esta nueva variable.</p>
<pre class="r"><code>library(car)
lapop21$ing4rec = car::recode(lapop21$ing4, &quot;1:4=0; 5:7=1&quot;)
table(lapop21$ing4rec)</code></pre>
<pre><code>## 
##     0     1 
## 21428 39035</code></pre>
<p>Si sumamos las observaciones entre 1 y 4 de la variable original
(5704+2567+4980+8177), vemos que es el resultado que tenemos en el valor
0 de la nueva variable (21428), tal como planteamos en la
recodificación. También debemos notar que la base de datos en el
Environment ahora tiene una variable más, totalizando 1826
variables.</p>
</div>
<div id="selección-de-casos" class="section level1">
<h1>Selección de casos</h1>
<p>El gráfico 1.1 muestra que el apoyo a la democracia va de un máximo
de 80% en Uruguay a un mínimo de 46% en Haití. Para replicar el
resultado correspondiente a Uruguay podemos seleccionar las
observaciones de ese país. De acuerdo a la codificación de la variable
“pais”, Uruguay tiene el código 14.</p>
<p><img src="pais.png" width="552" /></p>
<p>La selección de casos en R se puede hacer de múltiples maneras. Una
forma es usar los corchetes <code>[…]</code>. Otra forma es usando el
comando <code>subset</code>. Con este comando seleccionamos las
observaciones de este país y guardamos esta selección en un nuevo
dataframe “lapop2” usando este último comando. Se tiene 3009
observaciones en Uruguay.</p>
<pre class="r"><code>lapop1 = subset(lapop21, pais==14)
table(lapop1$pais)</code></pre>
<pre><code>## 
##   14 
## 3009</code></pre>
<p>Con esta selección de datos, podemos calcular el porcentaje
(frecuencias relativas) usando el comando <code>prop.table</code>. Este
comando nos brinda las frecuencias relativas (en valores entre 0 y 1) de
una tabla de frecuencias calculada con <code>table</code>. Estas
frecuencias relativas se multiplican por 100 para reproducir el
porcentaje en cada país. En este caso se usan los <code>[…]</code> para
hacer la selección de casos de cada país.</p>
<pre class="r"><code>prop.table(table(lapop1$ing4rec[lapop1$pais==14]))*100</code></pre>
<pre><code>## 
##        0        1 
## 15.47499 84.52501</code></pre>
<p>Estos resultados son porcentajes (entre 0 y 100), pero incluyen
muchos decimales. Para redondear a un decimal, como se muestra en el
Gráfico 1.2, podemos usar el comando <code>round</code>, donde anidamos
toda la sintaxis anterior. En este comando, además, tenemos que
especificar el número de decimales que se quiere, que en este caso es
1.</p>
<pre class="r"><code>round(prop.table(table(lapop1$ing4rec[lapop1$pais==14]))*100, 1)</code></pre>
<pre><code>## 
##    0    1 
## 15.5 84.5</code></pre>
<p>Según este resultado 84.5% de uruguayos apoya a la democracia. Este
resultado es distinto al que se reporta en el gráfico 1.1, donde el
valor reportado es 80%. Esta diferencia es debido a que estos primeros
procedimientos no incluyen el efecto de diseño. Más abajo veremos el
procedimiento para reproducir el resultado exacto reportado.</p>
<p>En el reporte de la ronda 2018/19 el reporte indica que “El Gráfico
1.2 muestra el porcentaje de personas en cada país que expresa apoyar la
democracia en 2018/19. El apoyo a la democracia va de un mínimo de 45%
en Honduras a un máximo de 76.2% en Uruguay” (p.11).</p>
<p>Para replicar estos resultados acerca de Honduras y de Uruguay para
2018/19, podemos seleccionar los datos de estos dos países. De acuerdo
al cuestionario, que se puede ver <a
href="https://www.vanderbilt.edu/lapop/ab2018/AB2018-v12.0-Spa-190131_W.pdf">aquí</a>,
Honduras es el país 4 y Uruguay es el país 14 de la variable “pais”, que
también se ha importando como una variable numérica.</p>
<p>Se incluye el operador “o”, que en R se denota con “|”. De esta
manera se indica que se selecciones las observaciones de Honduras o de
Uruguay (<code>pais==4 | pais==14</code>). La descripción de la variable
“pais” muestra que solo incluye los casos de Honduras (2) y Uruguay
(14).</p>
<pre class="r"><code># lapop2 &lt;- lapop18[lapop18$pais == 4 | lapop18$pais==14, ]
lapop2 = subset(lapop18, pais==4 | pais==14)
table(lapop2$pais)</code></pre>
<pre><code>## 
##    4   14 
## 1560 1581</code></pre>
<p>El nuevo dataframe “lapop2” tiene 3141 observaciones y 84 variables
debido a que no hemos creado la variable recodificada.</p>
<pre class="r"><code>lapop2$ing4rec = car::recode(lapop2$ing4, &quot;1:4=0; 5:7=1&quot;)</code></pre>
<p>Con esta variable podemos seguir los mismos procedimientos
anteriormente descritos para producir la tabla de frecuencias
relativas.</p>
<pre class="r"><code>prop.table(table(lapop2$ing4rec[lapop2$pais==4]))*100</code></pre>
<pre><code>## 
##        0        1 
## 54.98995 45.01005</code></pre>
<pre class="r"><code>prop.table(table(lapop2$ing4rec[lapop2$pais==14]))*100</code></pre>
<pre><code>## 
##        0        1 
## 23.80641 76.19359</code></pre>
<p>Y luego incluir el redondeo.</p>
<pre class="r"><code>round(prop.table(table(lapop2$ing4rec[lapop2$pais==4]))*100, 1)</code></pre>
<pre><code>## 
##  0  1 
## 55 45</code></pre>
<pre class="r"><code>round(prop.table(table(lapop2$ing4rec[lapop2$pais==14]))*100, 1)</code></pre>
<pre><code>## 
##    0    1 
## 23.8 76.2</code></pre>
<p>Con este código hemos reproducido los resultados de los países en los
extremos del Gráfico 1.2 del reporte. En este caso, los resultados sí
son similares a los reportados en el gráfico.</p>
<p>Ambos reportes también indican que se excluye de los cálculos a
Estados Unidos y Canadá. La base de datos cargada como “lapop18” incluye
a todos los países de la ronda. Para excluir a estos dos países, tenemos
que seleccionar los países que NO son EE.UU. y Canadá. Esta nueva
selección la guardamos en un nuevo dataframe o se puede sobreescribir en
el dataframe original, como se hace en este caso debido a que la
exclusión de estos países es para todos los cálculos que siguen. De
acuerdo al cuestionario, EE.UU. tiene el código 40 y Canadá, el código
41 en la variable “pais”. Para excluirlos tenemos que incluir a los
países que tengan un código menor a 40 (o de 35 o menos). Para esto
nuevamente podemos usar el comando <code>subset</code>.</p>
<pre class="r"><code>lapop18 = subset(lapop18, pais&lt;=35)</code></pre>
<p>Podemos observar en el Environment que se reducen las observaciones
del dataframe “lapop18” luego de correr este código, pues hemos
eliminado las observaciones de entrevistados en estos dos países. El
número de observaciones pasa de 31,050 a 28,042, número que coincide con
el de la base de datos en formato .RData que no incluía a estos
países.</p>
<p>De la misma manera podemos proceder en la base de datos de la ronda
2021, con lo que disminuyen las observaciones a 60661.</p>
<pre class="r"><code>lapop21 = subset(lapop21, pais&lt;=35)</code></pre>
</div>
<div id="calcular-una-variable" class="section level1">
<h1>Calcular una variable</h1>
<p>Una práctica frecuente de LAPOP con los datos del Barómetro de las
Américas es el re-escalamiento de variables. El capítulo sobre
legitimidad democrática del reporte brinda ejemplos de este
re-escalamiento con variables relacionadas al apoyo al sistema. Para
calcular este índice de apoyo al sistema se trabaja con un conjunto de
cinco variables:</p>
<p>B1. <em>¿Hasta qué punto cree usted que los tribunales de justicia de
(país) garantizan un juicio justo?</em></p>
<p>B2. <em>¿Hasta qué punto tiene usted respeto por las instituciones
políticas de (país)?</em></p>
<p>B3. <em>¿Hasta qué punto cree usted que los derechos básicos del
ciudadano están bien protegidos por el sistema político de
(país)?</em></p>
<p>B4. <em>¿Hasta qué punto se siente orgulloso de vivir bajo el sistema
político de (país)?</em></p>
<p>B6. <em>¿Hasta qué punto piensa usted que se debe apoyar al sistema
político de (país)?</em></p>
<p>Como indica el reporte “Para cada pregunta, la escala original de 1
(”Nada”) a 7 (“Mucho”) se recodifica en una escala de 0 a 100, de tal
forma que 0 indica el menor nivel de apoyo al sistema político y 100 es
el nivel máximo de apoyo al sistema político. Esta nueva escala sigue la
recodificación típica de LAPOP y puede ser interpretada como una
medición del apoyo en unidades, o grados, en una escala continua que va
de 0 a 100” (p.34). Para comprobar la escala original de estas
variables, se puede describir estas variables usando el comando
<code>table</code>.</p>
<pre class="r"><code>table(lapop18$b1)</code></pre>
<pre><code>## 
##    1    2    3    4    5    6    7 
## 4089 4067 5881 6137 4215 1631 1371</code></pre>
<pre class="r"><code>table(lapop18$b2)</code></pre>
<pre><code>## 
##    1    2    3    4    5    6    7 
## 2861 2152 2998 4153 5182 4448 5679</code></pre>
<pre class="r"><code>table(lapop18$b3)</code></pre>
<pre><code>## 
##    1    2    3    4    5    6    7 
## 5080 4096 5153 5349 4219 2061 1491</code></pre>
<pre class="r"><code>table(lapop18$b4)</code></pre>
<pre><code>## 
##    1    2    3    4    5    6    7 
## 5095 3206 3743 4557 4326 3041 3584</code></pre>
<pre class="r"><code>table(lapop18$b6)</code></pre>
<pre><code>## 
##    1    2    3    4    5    6    7 
## 3713 2325 2971 4277 4616 3868 5572</code></pre>
<p>Observamos que efectivamente todas las variables están en una escala
de 1 a 7. Para reescalar una variable en una escala original de 1 a 7 a
otra de 0 a 100, lo primero que tenemos que hacer es restar 1 unidad,
con lo que la variable tendría una escala de 0 a 6, luego dividirla
entre 6, con lo que variaría entre 0 y 1 y, finalmente, multiplicarla
por 100. Esto es:</p>
<p>Variable reescalada = ((variable original -1)/6)*100</p>
<pre class="r"><code>lapop18$b1rec = ((lapop18$b1-1)/6)*100
lapop18$b2rec = ((lapop18$b2-1)/6)*100
lapop18$b3rec = ((lapop18$b3-1)/6)*100
lapop18$b4rec = ((lapop18$b4-1)/6)*100
lapop18$b6rec = ((lapop18$b6-1)/6)*100
table(lapop18$b1rec)</code></pre>
<pre><code>## 
##                0 16.6666666666667 33.3333333333333               50 
##             4089             4067             5881             6137 
## 66.6666666666667 83.3333333333333              100 
##             4215             1631             1371</code></pre>
<p>Con esta transformación observamos que los 4,089 entrevistados que
marcaron 1 en la pregunta B1, ahora tienen un puntaje de 0. Los 4,067
que marcaron 2, ahora tienen un puntaje de 16.67, es decir
2-1=1/6=0.1667*100=16.67. Esta misma operación se pudo hacer con el
comando <code>car::recode</code>, siguiendo la siguiente regla de
recodificación:</p>
<ul>
<li>Valor de 1 en variable original se recodifica como 0 en nueva
variable</li>
<li>Valor de 2 en variable original se recodifica como 16.67 en nueva
variable</li>
<li>Valor de 3 en variable original se recodifica como 33.33 en nueva
variable</li>
<li>Valor de 4 en variable original se recodifica como 50 en nueva
variable</li>
<li>Valor de 5 en variable original se recodifica como 66.67 en nueva
variable</li>
<li>Valor de 6 en variable original se recodifica como 83.33 en nueva
variable</li>
<li>Valor de 7 en variable original se recodifica como 100 en nueva
variable</li>
</ul>
<p>Esta manera de recodificar, sin embargo, es poco eficiente. Es más
simple usar la fórmula para calcular la recodificación.</p>
<p>Para calcular el índice de apoyo al sistema, el reporte indica que
“El índice de apoyo al sistema es el promedio de cinco preguntas: B1,
B2, B3, B4 y B6” (p.46). Es decir, con las variables reescaladas tenemos
que calcular el promedio de estas cinco variables para cada individuo
(es decir, en cada fila de la base de datos). Podríamos calcular esta
operación del promedio de forma manual.</p>
<p>Apoyo al sistema = (b1rec + b2rec + b3rec + b4rec + b6rec)/5</p>
<p>En R tenemos el comando <code>rowMeans</code> que sirva para calcular
promedios de ciertas columnas por cada fila. La sintaxis
<code>[, 86:90]</code> indica que realizaremos el cálculo del promedio
por filas para todas las filas y usando las columnas 86 a 90 del
dataframe “lapop18” (podríamos hacer el cálculo para algunas filas en
particular definiendo <code>[fila_n:fila_m, 86:90]</code>). Este
promedio lo guardamos en una nueva variable “apoyo”, que
describimos.</p>
<pre class="r"><code>lapop18$apoyo = rowMeans(lapop18[,85:89])
table(lapop18$apoyo)</code></pre>
<pre><code>## 
##                0 3.33333333333333 6.66666666666667               10 
##              634              368              439              525 
## 13.3333333333333 16.6666666666667               20 23.3333333333333 
##              527              550              834              745 
## 26.6666666666667               30 33.3333333333333 36.6666666666667 
##              810              911             1063             1086 
##               40 43.3333333333333 46.6666666666667               50 
##             1287             1317             1254             1487 
## 53.3333333333333 56.6666666666667               60 63.3333333333333 
##             1397             1408             1449             1243 
## 66.6666666666667               70 73.3333333333333 76.6666666666667 
##             1227             1113              988              827 
##               80 83.3333333333333 86.6666666666667               90 
##              820              572              445              369 
## 93.3333333333333 96.6666666666667              100 
##              245              131              210</code></pre>
<p>Con este índice podemos calcular el apoyo al sistema promedio para la
última ronda del Barómetro de las Américas, así como los promedios de
cada una de las variables que componen el índice. Usamos el comando
<code>mean</code> para el promedio y la especificación
<code>na.rm=T</code> para indicarle al comando que no tome en cuenta los
valores perdidos de estas variables. Veremos estos estadísticos en más
detalle en otras secciones.</p>
<pre class="r"><code>mean(lapop18$apoyo, na.rm=T)</code></pre>
<pre><code>## [1] 48.79419</code></pre>
<pre class="r"><code>mean(lapop18$b1rec, na.rm=T) #Cortes garantizan juicio justo</code></pre>
<pre><code>## [1] 41.06032</code></pre>
<pre class="r"><code>mean(lapop18$b2rec, na.rm=T) #Respeto a las instituciones</code></pre>
<pre><code>## [1] 59.23937</code></pre>
<pre class="r"><code>mean(lapop18$b3rec, na.rm=T) #Derechos básicos están protegidos</code></pre>
<pre><code>## [1] 40.42406</code></pre>
<pre class="r"><code>mean(lapop18$b4rec, na.rm=T) #Orgullos por el sistema político</code></pre>
<pre><code>## [1] 47.41096</code></pre>
<pre class="r"><code>mean(lapop18$b6rec, na.rm=T) #Se debería apoyar al sistema político</code></pre>
<pre><code>## [1] 56.28337</code></pre>
<p>Estos resultados son los que se muestran en el Gráfico 2.1 para la
ronda 2018/19.</p>
<p><img src="Graf2.1.png" width="629" /></p>
</div>
<div id="calcular-una-variable-de-manera-condicional"
class="section level1">
<h1>Calcular una variable de manera condicional</h1>
<p>En algunas ocasiones el cálculo de una variable no requiere solamente
la transformación numérica de la variable original, sino que los valores
de la nueva variable dependen de valores de otras variables. Por
ejemplo, el capítulo “Redes sociales y actitudes políticas” del reporte
“El Pulso de la Democracia” de la ronda 2018/19 presenta los resultados
para las variables “usuario de Whatsapp”, “usuario de Twitter” y
“usuario de Facebook”. Para calcular estas variables, el pie de página 7
de este capítulo indica: “Para cada plataforma, se identifican los
usuarios con una combinación de dos conjuntos de preguntas. Primero, se
identifican como usuarios a quienes responden positivamente a las
preguntas, SMEDIA1/SMEDIA4/SMEDIA7. ¿Tiene usted cuenta de
Facebook/Twitter/Whatsapp? Luego, se recodifica como no usuario a
quienes responden”nunca” a las preguntas siguientes,
SMEDIA2/SMEDIA5/SMEDIA8. ¿Con qué frecuencia ve contenido en
Facebook/Twitter/Whatsapp?” (p. 64).</p>
<p><img src="smedia.png" width="466" /></p>
<p>Es decir, el usuario no solo es el que tiene una cuenta (SMEDIA1=1),
sino el que la usa con cierta frecuencia (SMEDIA2=1, 2, 3, 4). De esta
manera, el no usuario puede tener una cuenta, pero nunca usarla. Por lo
tanto, la variable “usuario” depende de los valores de 2 variables. La
regla de codificación que se sigue es:</p>
<ul>
<li><p>Usuario de Facebook = 1 (sí es usuario) si SMEDIA1 = 1 (tiene
cuenta) y SMEDIA2 &lt;= 4 (la usa con alguna frecuencia)</p></li>
<li><p>Usuario de Facebook = 0 (no es usuario) si SMEDIA2 = 2 (no tiene
cuenta) o SMEDIA2 = 5 (tiene cuenta pero nunca la usa)</p></li>
</ul>
<p>Producimos esta regla de codificación con la siguiente sintaxis de R,
que usa el comando <code>ìfelse</code>. Esta sintaxis incluye la
condición para asignar valores de 1 a una nueva variable y asigna a
todas las demás observaciones el valor de 0. Describimos estas nuevas
variables usando los comandos <code>table</code> para generar las
frecuencias absolutas, <code>prop.table</code> para las frecuencias
relativas y <code>round</code> para redondear los decimales. Estos
comandos los veremos en más detalle en las siguientes secciones.</p>
<pre class="r"><code>lapop18$fb_user = ifelse(lapop18$smedia1==1 &amp; lapop18$smedia2&lt;=4, 1, 0)
lapop18$tw_user = ifelse(lapop18$smedia4==1 &amp; lapop18$smedia5&lt;=4, 1, 0)
lapop18$wa_user = ifelse(lapop18$smedia7==1 &amp; lapop18$smedia8&lt;=4, 1, 0)
round(prop.table(table(lapop18$fb_user))*100, 1)</code></pre>
<pre><code>## 
##    0    1 
## 43.8 56.2</code></pre>
<pre class="r"><code>round(prop.table(table(lapop18$tw_user))*100, 1)</code></pre>
<pre><code>## 
##    0    1 
## 92.1  7.9</code></pre>
<pre class="r"><code>round(prop.table(table(lapop18$wa_user))*100, 1)</code></pre>
<pre><code>## 
##    0    1 
## 35.8 64.2</code></pre>
<p>Estos resultados son los que se presentan en el Gráfico 3.1 del
reporte en forma de gráficos circulares. Veremos este tipo de gráficos
en la siguiente sección.</p>
<p><img src="Graf3.1.png" width="323" /></p>
</div>
<div id="observación-del-efecto-de-diseño" class="section level1">
<h1>Observación del efecto de diseño</h1>
<p>Tanto los resultados para apoyo al sistema, como los de usuarios de
redes sociales difieren de los que aparecen en el reporte por dos
motivos. En primer lugar, para apoyo al sistema, debido a que “Los
valores a lo largo del tiempo se calculan incluyendo únicamente los
países que el Barómetro de las Américas ha estudiado regularmente desde
2006: Argentina, Brasil, Bolivia, Chile, Colombia, Costa Rica, República
Dominicana, Ecuador, El Salvador, Guatemala, Honduras, Jamaica, México,
Nicaragua, Panamá, Paraguay, Perú, Uruguay” (p.46). El código solo
filtra la última ronda, que incluye países que no están en esa lista,
como Estados Unidos o Canadá. De otro lado, los cálculos reportados en
la publicación incluyen el uso de factores de ponderación, que no hemos
incluido en estos cálculos, pero que en otros documentos incorporaremos
(ver <a href="https://rpubs.com/arturo_maldonado/728626">aquí</a>).</p>
</div>
<div id="resumen" class="section level1">
<h1>Resumen</h1>
<p>En este documento hemos visto los elementos básicos de la
manipulación y transformación de datos usando el Barómetro de las
Américas. Hemos recodificado una variable usando el comando
<code>recode</code>, hemos seleccionado casos usando <code>subset</code>
y hemos calculado una nueva variable algebraicamente y con el comando
<code>ifelse</code>.</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiTWFuZWpvIGRlIGRhdG9zIHVzYW5kbyBlbCBCYXLDs21ldHJvIGRlIGxhcyBBbcOpcmljYXMiCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdG9jOiB0cnVlCiAgICB0b2NfZmxvYXQ6IHRydWUKICAgIGNvbGxhcHNlZDogZmFsc2UKICAgIG51bWJlcl9zZWN0aW9uczogZmFsc2UKICAgIHRvY19kZXB0aDogMQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQogICAgdGhlbWU6IGZsYXRseQogICAgI2NvZGVfZm9sZGluZzogaGlkZQplZGl0b3Jfb3B0aW9uczogCiAgbWFya2Rvd246IAogICAgd3JhcDogc2VudGVuY2UKLS0tCgpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KG1lc3NhZ2U9RkFMU0Usd2FybmluZz1GQUxTRSwgY2FjaGU9VFJVRSkKYGBgCgpgYGB7Y3NzIGNvbG9yLCBlY2hvPUZBTFNFfQouY29sdW1ucyB7ZGlzcGxheTogZmxleDt9CmgxIHtjb2xvcjogIzMzNjZDQzt9CmBgYAoKIyBJbnRyb2R1Y2Npw7NuCgpFbiBlc3RlIGRvY3VtZW50byB2ZXJlbW9zIGFzcGVjdG9zIGLDoXNpY29zIGRlbCBtYW5lam8gZGUgZGF0b3MsIGNvbW8gbGEgcmVjb2RpZmljYWNpw7NuIGRlIHVuYSB2YXJpYWJsZSwgbGEgc2VsZWNjacOzbiBkZSBkYXRvcyB5IGVsIGPDoWxjdWxvIGRlIHVuYSBudWV2YSB2YXJpYWJsZS4KQWwgZmluYWwgaW5jbHXDrW1vcyB1bmEgbm90YSBhY2VyY2EgZGUgbG9zIGPDoWxjdWxvcyBlc3RhZMOtc3RpY29zIGNvbnNpZGVyYW5kbyBlbCBlZmVjdG8gZGUgZGlzZcOxby4KCiMgU29icmUgbGEgYmFzZSBkZSBkYXRvcwoKTG9zIGRhdG9zIHF1ZSB2YW1vcyBhIHVzYXIgZGViZW4gY2l0YXJzZSBkZSBsYSBzaWd1aWVudGUgbWFuZXJhOiBGdWVudGU6IEJhcsOzbWV0cm8gZGUgbGFzIEFtw6lyaWNhcyBwb3IgZWwgUHJveWVjdG8gZGUgT3BpbmnDs24gUMO6YmxpY2EgZGUgQW3DqXJpY2EgTGF0aW5hIChMQVBPUCksIHd3d3cuTGFwb3BTdXJ2ZXlzLm9yZy4KCkVuIGVzdGUgZG9jdW1lbnRvIGNhcmdhbW9zIHVuYSBiYXNlIHF1ZSBzZSBlbmN1ZW50cmEgYWxvamFkYSBlbiBlbCByZXBvc2l0b3JpbyAibWF0ZXJpYWxzX2VkdSIgZGUgbGEgY3VlbnRhIGRlIExBUE9QIGVuIEdpdEh1Yi4KTWVkaWFudGUgbGEgbGlicmVyw61hIGByaW9gIHkgZWwgY29tYW5kbyBgaW1wb3J0YCBzZSBwdWVkZSBpbXBvcnRhciBlc3RhIGJhc2UgZGUgZGF0b3MgZGVzZGUgZXN0ZSByZXBvc2l0b3JpbywgdXNhbmRvIGVsIHNpZ3VpZW50ZSBjw7NkaWdvLgpJbXBvcnRhbW9zIGxhIGJhc2UgZGUgZGF0b3MgZW4gdW4gb2JqZXRvICJsYXBvcDIxIi4KRXN0YSBiYXNlIGRlIGRhdG9zIHRpZW5lIGV4dGVuc2nDs24gLlJEYXRhIHkgY3VhbmRvIHNlIGltcG9ydGEsIGNhcmdhIGxhcyB2YXJpYWJsZXMgY29tbyBkZWwgdGlwbyBkb3VibGUgKCJkYmwiKSwgcXVlIGVzIHVuIHRpcG8gZGUgdmFyaWFibGUgbnVtw6lyaWNhIHF1ZSBhY2VwdGEgZGVjaW1hbGVzLCBhIGRpZmVyZW5jaWEgZGVsIHRpcG8gaW50ZWdlciwgImludCIsIHF1ZSBzb2xvIGFjZXB0YSBlbnRlcm9zLgoKYGBge3IgYmFzZTIxLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KHJpbykKbGFwb3AyMSA9IGltcG9ydCgiaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9sYXBvcC1jZW50cmFsL21hdGVyaWFsc19lZHUvbWFpbi9sYXBvcDIxLlJEYXRhIikKYGBgCgpFbiBlc3RlIHJlcG9zaXRvcmlvIHRhbWJpw6luIHNlIGVuY3VlbnRyYSBsYSBiYXNlIGRlIGRhdG9zIGRlIGxhIHJvbmRhIGFudGVyaW9yLCBsYSBxdWUgdGFtYmnDqW4gcG9kZW1vcyBjYXJnYXIgeSBsbGFtYXJsYSAibGFwb3AxOCIuCkVzIG5lY2VzYXJpbyBhY2xhcmFyIHF1ZSBlc3RhIGJhc2UgZGUgZGF0b3MsIGltcG9ydGFkYSBkZXNkZSB1biBhcmNoaXZvIFNQU1MsIGNhcmdhIGxhcyB2YXJpYWJsZXMgY29tbyBkZWwgdGlwbyBudW3DqXJpY2FzICgibnVtIikgcXVlIHBhcmEgZmluZXMgcHLDoWN0aWNvcyBlcyBpZ3VhbCBhbCBmb3JtYXRvIGRvYmxlICgiZGJsIikuCgpgYGB7ciBiYXNlMTh9CmxhcG9wMTggPSBpbXBvcnQoImh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vbGFwb3AtY2VudHJhbC9tYXRlcmlhbHNfZWR1L21haW4vTEFQT1BfQUJfTWVyZ2VfMjAxOF92MS4wLnNhdiIpCmBgYAoKIyBSZWNvZGlmaWNhY2nDs24gZGUgdW5hIHZhcmlhYmxlCgpFbiBlc3RhIHNlY2Npw7NuIHVzYXJlbW9zIGVsIHJlcG9ydGUgIkVsIFB1bHNvIGRlIGxhIERlbW9jcmFjaWEiLCBjb24gbG9zIHJlc3VsdGFkb3MgZGUgbGEgw7psdGltYSByb25kYSAyMDIxIGRlbCBCYXLDs21ldHJvIGRlIGxhcyBBbcOpcmljYXMsIGRpc3BvbmlibGUgW2FxdcOtXShodHRwczovL3d3dy52YW5kZXJiaWx0LmVkdS9sYXBvcC9hYjIwMjEvMjAyMV9MQVBPUF9BbWVyaWNhc0Jhcm9tZXRlcl9QdWxzZV9vZl9EZW1vY3JhY3kucGRmKS4KRXN0ZSByZXBvcnRlIHByZXNlbnRhIGxvcyByZXN1bHRhZG9zIGFjZXJjYSBkZWwgYXBveW8gYSBsYSBkZW1vY3JhY2lhIGVuIGxhcyBBbcOpcmljYXMuCkVzdG9zIHJlc3VsdGFkb3Mgc2UgYmFzYW4gZW4gbGEgdmFyaWFibGUgSU5HNCBkZSBsYSBiYXNlIGRlIGRhdG9zLgpFc3RhIHZhcmlhYmxlIGVzdMOhIGZyYXNlYWRhIGRlIGxhIHNpZ3VpZW50ZSBtYW5lcmE6CgoqKklORzQuKiogKkNhbWJpYW5kbyBkZSBudWV2byBkZSB0ZW1hLCBwdWVkZSBxdWUgbGEgZGVtb2NyYWNpYSB0ZW5nYSBwcm9ibGVtYXMsIHBlcm8gZXMgbWVqb3IgcXVlIGN1YWxxdWllciBvdHJhIGZvcm1hIGRlIGdvYmllcm5vLiDCv0hhc3RhIHF1w6kgcHVudG8gZXN0w6EgZGUgYWN1ZXJkbyBvIGVuIGRlc2FjdWVyZG8gY29uIGVzdGEgZnJhc2U/KgoKRXN0YSB2YXJpYWJsZSBlc3TDoSBtZWRpZGEgZW4gdW5hIGVzY2FsYSBkZWwgMSBhIDcsIGRvbmRlIDEgc2lnbmlmaWNhICJtdXkgZW4gZGVzYWN1ZXJkbyIgeSA3IHNpZ25pZmljYSAibXV5IGRlIGFjdWVyZG8iLgpMdWVnbywgbG9zIHZhbG9yZXMgZW50cmUgNSBhIDcgc29uIHJlY29kaWZpY2Fkb3MgY29tbyBhcG95byBhIGxhIGRlbW9jcmFjaWEuClBhcmEgdmVyIGxhIGRpc3RyaWJ1Y2nDs24gZGUgcmVzcHVlc3RhcyBhIGVzdGEgdmFyaWFibGUsIHBvZGVtb3MgdXNhciBlbCBjb21hbmRvIGB0YWJsZWAuCgpgYGB7ciBkZXNjcmliaXIgaW5nNH0KdGFibGUobGFwb3AyMSRpbmc0KQpgYGAKCkRlIGVzdGEgbWFuZXJhIGNhbGN1bGFtb3MgbGFzIG9ic2VydmFjaW9uZXMgKGZyZWN1ZW5jaWFzIGFic29sdXRhcykgcG9yIGNhZGEgdmFsb3IgZGUgbGEgdmFyaWFibGUuClBhcmEgY2FsY3VsYXIgZWwgcG9yY2VudGFqZSBkZSBwZXJzb25hcyBxdWUgYXBveWEgYSBsYSBkZW1vY3JhY2lhIHRlbmVtb3MgcXVlIHJlY29kaWZpY2FyIGVzdGEgdmFyaWFibGUgeSBjcmVhciB1bmEgbnVldmEuCkVzIGRlY2lyLCBsYSB2YXJpYWJsZSBvcmlnaW5hbCBJTkc0LCBlbiB1bmEgZXNjYWxhIGRlIDEtNywgbGEgcmVjb2RpZmljYW1vcyBlbiB1bmEgbnVldmEgdmFyaWFibGUsIHNpZ3VpZW5kbyBsYSBzaWd1aWVudGUgcmVnbGE6CgoxLiAgVmFsb3JlcyBlbnRyZSAxLTQgZGUgSU5HNCBzZSB0cmFuc2Zvcm1hbiBlbiAwIGVuIHVuYSBudWV2YSB2YXJpYWJsZSBpbmc0cgoyLiAgVmFsb3JlcyBlbnRyZSA1LTcgZGUgSU5HNCBzZSB0cmFuc2Zvcm1lbiBlbiAxIGVuIHVuYSBudWV2YSB2YXJpYWJsZSBpbmc0cgoKVW4gZWplbXBsbyBkZSBjw7NtbyBzZSBwcmVzZW50YW4gZXN0b3MgZGF0b3MgcmVjb2RpZmljYWRvcyBlbiBlbCByZXBvcnRlIHNlIHB1ZWRlIHZlciBlbiBlbCBHcsOhZmljbyAxLjEuCkVzdGUgbXVlc3RyYSBlbCBwb3JjZW50YWplIGRlIGNpdWRhZGFub3MgcXVlIGFwb3lhIGEgbGEgZGVtb2NyYWNpYSBwb3IgcGHDrXMuCkVzIGRlY2lyLCBzZSBtdWVzdHJhIGVsIHBvcmNlbnRhamUgZGUgZW50cmV2aXN0YWRvcyBxdWUgcmVzcG9uZGllcm9uIGVudHJlIDUgeSA3IGEgbGEgcHJlZ3VudGEgSU5HNCBlbiBjYWRhIHBhw61zLgpEZSBhY3VlcmRvIGEgbGEgcmVjb2RpZmljYWNpw7NuIHBsYW50ZWFkYSwgZXN0ZSBncsOhZmljbyByZXByZXNlbnRhcsOtYSBlbCBwb3JjZW50YWplIGRlIGVudHJldmlzdGFkb3MgcXVlIHJlZ2lzdHJhIHVuIDEgZW4gbGEgdmFyaWFibGUgcmVjb2RpZmljYWRhLgoKIVtdKEdyYWZpY28xLjEucG5nKQoKRW4gZWwgaW5mb3JtZSBFbCBQdWxzbyBkZSBsYSBEZW1vY3JhY2lhIGRlIGxhIHJvbmRhIDIwMTgvMTksIGRpc3BvbmlibGUgW2FxdcOtXShodHRwczovL3d3dy52YW5kZXJiaWx0LmVkdS9sYXBvcC9hYjIwMTgvMjAxOC0xOV9BbWVyaWNhc0Jhcm9tZXRlcl9SZWdpb25hbF9SZXBvcnRfU3BhbmlzaF9XXzAzLjI3LjIwLnBkZiksIHRhbWJpw6luIHNlIHByZXNlbnRhIHVuIGdyw6FmaWNvIHNpbWlsYXIsIHVzYW5kbyBsYSBtaXNtYSB2YXJpYWJsZSB5IGxhIG1pc21hIHJlZ2xhIGRlIHJlY29kaWZpY2Fjw61vbi4KCiFbXShHcmFmMS4yLnBuZyl7d2lkdGg9IjM1MCJ9CgpQYXJhIHJlY29kaWZpY2FyIHVuYSB2YXJpYWJsZSBlbiBSIGhheSB2YXJpYXMgZm9ybWFzLgpVbmEgZGUgbGFzIGZvcm1hcyBtw6FzIGVmaWNpZW50ZXMgZGUgaGFjZXJsbyBlcyB1c2FuZG8gZWwgY29tYW5kbyBgcmVjb2RlYCBkZWwgcGFxdWV0ZSBgY2FyYC4KRWwgcGFxdWV0ZSBgZHBseXJgIHRpZW5lIHVuIGNvbWFuZG8gYHJlY29kZWAgcXVlIHB1ZWRlIGNvbmZ1bmRpciBhIFIuClBhcmEgZXZpdGFyIGNvbmZ1c2lvbmVzIHVzYXJlbW9zIGxhIHNpbnRheGlzIGBjYXI6OnJlY29kZWAgcGFyYSBsYSByZWNvZGlmaWNhY2nDs24sIGVzIGRlY2lyIHBhcmEgZXNwZWNpZmljYXIgcXVlIHNlIHVzZSBlbCBjb21hbmRvIGByZWNvZGVgZGVsIHBhcXVldGUgYGNhcmAgeSBubyBkZSBvdHJvLgpHdWFyZGFtb3MgbGEgdmFyaWFibGUgcmVjb2RpZmljYWRhIGNvbW8gImxhcG9wMjFcJGluZzRyZWMgKGVzIGRlY2lyLCBjcmVhbW9zIHVuYSBudWV2YSB2YXJpYWJsZSBvIHZlY3RvciBlbiBlbCBkYXRhZnJhbWUpLiBMdWVnbywgdXNhbW9zIGVsIGNvbWFuZG8gYHRhYmxlYCBwYXJhIGRlc2NyaWJpciBlc3RhIG51ZXZhIHZhcmlhYmxlLgoKYGBge3IgcmVjb2RpZmljYWNpb24sIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkoY2FyKQpsYXBvcDIxJGluZzRyZWMgPSBjYXI6OnJlY29kZShsYXBvcDIxJGluZzQsICIxOjQ9MDsgNTo3PTEiKQp0YWJsZShsYXBvcDIxJGluZzRyZWMpCmBgYAoKU2kgc3VtYW1vcyBsYXMgb2JzZXJ2YWNpb25lcyBlbnRyZSAxIHkgNCBkZSBsYSB2YXJpYWJsZSBvcmlnaW5hbCAoNTcwNCsyNTY3KzQ5ODArODE3NyksIHZlbW9zIHF1ZSBlcyBlbCByZXN1bHRhZG8gcXVlIHRlbmVtb3MgZW4gZWwgdmFsb3IgMCBkZSBsYSBudWV2YSB2YXJpYWJsZSAoMjE0MjgpLCB0YWwgY29tbyBwbGFudGVhbW9zIGVuIGxhIHJlY29kaWZpY2FjacOzbi4KVGFtYmnDqW4gZGViZW1vcyBub3RhciBxdWUgbGEgYmFzZSBkZSBkYXRvcyBlbiBlbCBFbnZpcm9ubWVudCBhaG9yYSB0aWVuZSB1bmEgdmFyaWFibGUgbcOhcywgdG90YWxpemFuZG8gMTgyNiB2YXJpYWJsZXMuCgojIFNlbGVjY2nDs24gZGUgY2Fzb3MKCkVsIGdyw6FmaWNvIDEuMSBtdWVzdHJhIHF1ZSBlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEgdmEgZGUgdW4gbcOheGltbyBkZSA4MCUgZW4gVXJ1Z3VheSBhIHVuIG3DrW5pbW8gZGUgNDYlIGVuIEhhaXTDrS4KUGFyYSByZXBsaWNhciBlbCByZXN1bHRhZG8gY29ycmVzcG9uZGllbnRlIGEgVXJ1Z3VheSBwb2RlbW9zIHNlbGVjY2lvbmFyIGxhcyBvYnNlcnZhY2lvbmVzIGRlIGVzZSBwYcOtcy4KRGUgYWN1ZXJkbyBhIGxhIGNvZGlmaWNhY2nDs24gZGUgbGEgdmFyaWFibGUgInBhaXMiLCBVcnVndWF5IHRpZW5lIGVsIGPDs2RpZ28gMTQuCgohW10ocGFpcy5wbmcpe3dpZHRoPSI1NTIifQoKTGEgc2VsZWNjacOzbiBkZSBjYXNvcyBlbiBSIHNlIHB1ZWRlIGhhY2VyIGRlIG3Dumx0aXBsZXMgbWFuZXJhcy4KVW5hIGZvcm1hIGVzIHVzYXIgbG9zIGNvcmNoZXRlcyBgW+KApl1gLgpPdHJhIGZvcm1hIGVzIHVzYW5kbyBlbCBjb21hbmRvIGBzdWJzZXRgLgpDb24gZXN0ZSBjb21hbmRvIHNlbGVjY2lvbmFtb3MgbGFzIG9ic2VydmFjaW9uZXMgZGUgZXN0ZSBwYcOtcyB5IGd1YXJkYW1vcyBlc3RhIHNlbGVjY2nDs24gZW4gdW4gbnVldm8gZGF0YWZyYW1lICJsYXBvcDIiIHVzYW5kbyBlc3RlIMO6bHRpbW8gY29tYW5kby4KU2UgdGllbmUgMzAwOSBvYnNlcnZhY2lvbmVzIGVuIFVydWd1YXkuCgpgYGB7ciBzZWxlY2Npb25hciBVcnV9CmxhcG9wMSA9IHN1YnNldChsYXBvcDIxLCBwYWlzPT0xNCkKdGFibGUobGFwb3AxJHBhaXMpCmBgYAoKQ29uIGVzdGEgc2VsZWNjacOzbiBkZSBkYXRvcywgcG9kZW1vcyBjYWxjdWxhciBlbCBwb3JjZW50YWplIChmcmVjdWVuY2lhcyByZWxhdGl2YXMpIHVzYW5kbyBlbCBjb21hbmRvIGBwcm9wLnRhYmxlYC4KRXN0ZSBjb21hbmRvIG5vcyBicmluZGEgbGFzIGZyZWN1ZW5jaWFzIHJlbGF0aXZhcyAoZW4gdmFsb3JlcyBlbnRyZSAwIHkgMSkgZGUgdW5hIHRhYmxhIGRlIGZyZWN1ZW5jaWFzIGNhbGN1bGFkYSBjb24gYHRhYmxlYC4KRXN0YXMgZnJlY3VlbmNpYXMgcmVsYXRpdmFzIHNlIG11bHRpcGxpY2FuIHBvciAxMDAgcGFyYSByZXByb2R1Y2lyIGVsIHBvcmNlbnRhamUgZW4gY2FkYSBwYcOtcy4KRW4gZXN0ZSBjYXNvIHNlIHVzYW4gbG9zIGBb4oCmXWAgcGFyYSBoYWNlciBsYSBzZWxlY2Npw7NuIGRlIGNhc29zIGRlIGNhZGEgcGHDrXMuCgpgYGB7ciBwb3JjZW50YWplIFVydX0KcHJvcC50YWJsZSh0YWJsZShsYXBvcDEkaW5nNHJlY1tsYXBvcDEkcGFpcz09MTRdKSkqMTAwCmBgYAoKRXN0b3MgcmVzdWx0YWRvcyBzb24gcG9yY2VudGFqZXMgKGVudHJlIDAgeSAxMDApLCBwZXJvIGluY2x1eWVuIG11Y2hvcyBkZWNpbWFsZXMuClBhcmEgcmVkb25kZWFyIGEgdW4gZGVjaW1hbCwgY29tbyBzZSBtdWVzdHJhIGVuIGVsIEdyw6FmaWNvIDEuMiwgcG9kZW1vcyB1c2FyIGVsIGNvbWFuZG8gYHJvdW5kYCwgZG9uZGUgYW5pZGFtb3MgdG9kYSBsYSBzaW50YXhpcyBhbnRlcmlvci4KRW4gZXN0ZSBjb21hbmRvLCBhZGVtw6FzLCB0ZW5lbW9zIHF1ZSBlc3BlY2lmaWNhciBlbCBuw7ptZXJvIGRlIGRlY2ltYWxlcyBxdWUgc2UgcXVpZXJlLCBxdWUgZW4gZXN0ZSBjYXNvIGVzIDEuCgpgYGB7ciByZWRvbmRlYXIgVXJ1fQpyb3VuZChwcm9wLnRhYmxlKHRhYmxlKGxhcG9wMSRpbmc0cmVjW2xhcG9wMSRwYWlzPT0xNF0pKSoxMDAsIDEpCmBgYAoKU2Vnw7puIGVzdGUgcmVzdWx0YWRvIDg0LjUlIGRlIHVydWd1YXlvcyBhcG95YSBhIGxhIGRlbW9jcmFjaWEuCkVzdGUgcmVzdWx0YWRvIGVzIGRpc3RpbnRvIGFsIHF1ZSBzZSByZXBvcnRhIGVuIGVsIGdyw6FmaWNvIDEuMSwgZG9uZGUgZWwgdmFsb3IgcmVwb3J0YWRvIGVzIDgwJS4KRXN0YSBkaWZlcmVuY2lhIGVzIGRlYmlkbyBhIHF1ZSBlc3RvcyBwcmltZXJvcyBwcm9jZWRpbWllbnRvcyBubyBpbmNsdXllbiBlbCBlZmVjdG8gZGUgZGlzZcOxby4KTcOhcyBhYmFqbyB2ZXJlbW9zIGVsIHByb2NlZGltaWVudG8gcGFyYSByZXByb2R1Y2lyIGVsIHJlc3VsdGFkbyBleGFjdG8gcmVwb3J0YWRvLgoKRW4gZWwgcmVwb3J0ZSBkZSBsYSByb25kYSAyMDE4LzE5IGVsIHJlcG9ydGUgaW5kaWNhIHF1ZSAiRWwgR3LDoWZpY28gMS4yIG11ZXN0cmEgZWwgcG9yY2VudGFqZSBkZSBwZXJzb25hcyBlbiBjYWRhIHBhw61zIHF1ZSBleHByZXNhIGFwb3lhciBsYSBkZW1vY3JhY2lhIGVuIDIwMTgvMTkuIEVsIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSB2YSBkZSB1biBtw61uaW1vIGRlIDQ1JSBlbiBIb25kdXJhcyBhIHVuIG3DoXhpbW8gZGUgNzYuMiUgZW4gVXJ1Z3VheSIgKHAuMTEpLgoKUGFyYSByZXBsaWNhciBlc3RvcyByZXN1bHRhZG9zIGFjZXJjYSBkZSBIb25kdXJhcyB5IGRlIFVydWd1YXkgcGFyYSAyMDE4LzE5LCBwb2RlbW9zIHNlbGVjY2lvbmFyIGxvcyBkYXRvcyBkZSBlc3RvcyBkb3MgcGHDrXNlcy4KRGUgYWN1ZXJkbyBhbCBjdWVzdGlvbmFyaW8sIHF1ZSBzZSBwdWVkZSB2ZXIgW2FxdcOtXShodHRwczovL3d3dy52YW5kZXJiaWx0LmVkdS9sYXBvcC9hYjIwMTgvQUIyMDE4LXYxMi4wLVNwYS0xOTAxMzFfVy5wZGYpLCBIb25kdXJhcyBlcyBlbCBwYcOtcyA0IHkgVXJ1Z3VheSBlcyBlbCBwYcOtcyAxNCBkZSBsYSB2YXJpYWJsZSAicGFpcyIsIHF1ZSB0YW1iacOpbiBzZSBoYSBpbXBvcnRhbmRvIGNvbW8gdW5hIHZhcmlhYmxlIG51bcOpcmljYS4KClNlIGluY2x1eWUgZWwgb3BlcmFkb3IgIm8iLCBxdWUgZW4gUiBzZSBkZW5vdGEgY29uICJcfCIuCkRlIGVzdGEgbWFuZXJhIHNlIGluZGljYSBxdWUgc2Ugc2VsZWNjaW9uZXMgbGFzIG9ic2VydmFjaW9uZXMgZGUgSG9uZHVyYXMgbyBkZSBVcnVndWF5IChgcGFpcz09NCB8IHBhaXM9PTE0YCkuCkxhIGRlc2NyaXBjacOzbiBkZSBsYSB2YXJpYWJsZSAicGFpcyIgbXVlc3RyYSBxdWUgc29sbyBpbmNsdXllIGxvcyBjYXNvcyBkZSBIb25kdXJhcyAoMikgeSBVcnVndWF5ICgxNCkuCgpgYGB7ciBzZWxlY2Npb25hciBIb24geSBVcnV9CiMgbGFwb3AyIDwtIGxhcG9wMThbbGFwb3AxOCRwYWlzID09IDQgfCBsYXBvcDE4JHBhaXM9PTE0LCBdCmxhcG9wMiA9IHN1YnNldChsYXBvcDE4LCBwYWlzPT00IHwgcGFpcz09MTQpCnRhYmxlKGxhcG9wMiRwYWlzKQpgYGAKCkVsIG51ZXZvIGRhdGFmcmFtZSAibGFwb3AyIiB0aWVuZSAzMTQxIG9ic2VydmFjaW9uZXMgeSA4NCB2YXJpYWJsZXMgZGViaWRvIGEgcXVlIG5vIGhlbW9zIGNyZWFkbyBsYSB2YXJpYWJsZSByZWNvZGlmaWNhZGEuCgpgYGB7ciBhcG95byBIb24geSBVcnV9CmxhcG9wMiRpbmc0cmVjID0gY2FyOjpyZWNvZGUobGFwb3AyJGluZzQsICIxOjQ9MDsgNTo3PTEiKQpgYGAKCkNvbiBlc3RhIHZhcmlhYmxlIHBvZGVtb3Mgc2VndWlyIGxvcyBtaXNtb3MgcHJvY2VkaW1pZW50b3MgYW50ZXJpb3JtZW50ZSBkZXNjcml0b3MgcGFyYSBwcm9kdWNpciBsYSB0YWJsYSBkZSBmcmVjdWVuY2lhcyByZWxhdGl2YXMuCgpgYGB7ciBwb3JjZW50YWplcyBIb24geSBVcnV9CnByb3AudGFibGUodGFibGUobGFwb3AyJGluZzRyZWNbbGFwb3AyJHBhaXM9PTRdKSkqMTAwCnByb3AudGFibGUodGFibGUobGFwb3AyJGluZzRyZWNbbGFwb3AyJHBhaXM9PTE0XSkpKjEwMApgYGAKClkgbHVlZ28gaW5jbHVpciBlbCByZWRvbmRlby4KCmBgYHtyIHJlZG9uZGVhciBIb24geSBVcnV9CnJvdW5kKHByb3AudGFibGUodGFibGUobGFwb3AyJGluZzRyZWNbbGFwb3AyJHBhaXM9PTRdKSkqMTAwLCAxKQpyb3VuZChwcm9wLnRhYmxlKHRhYmxlKGxhcG9wMiRpbmc0cmVjW2xhcG9wMiRwYWlzPT0xNF0pKSoxMDAsIDEpCmBgYAoKQ29uIGVzdGUgY8OzZGlnbyBoZW1vcyByZXByb2R1Y2lkbyBsb3MgcmVzdWx0YWRvcyBkZSBsb3MgcGHDrXNlcyBlbiBsb3MgZXh0cmVtb3MgZGVsIEdyw6FmaWNvIDEuMiBkZWwgcmVwb3J0ZS4KRW4gZXN0ZSBjYXNvLCBsb3MgcmVzdWx0YWRvcyBzw60gc29uIHNpbWlsYXJlcyBhIGxvcyByZXBvcnRhZG9zIGVuIGVsIGdyw6FmaWNvLgoKQW1ib3MgcmVwb3J0ZXMgdGFtYmnDqW4gaW5kaWNhbiBxdWUgc2UgZXhjbHV5ZSBkZSBsb3MgY8OhbGN1bG9zIGEgRXN0YWRvcyBVbmlkb3MgeSBDYW5hZMOhLgpMYSBiYXNlIGRlIGRhdG9zIGNhcmdhZGEgY29tbyAibGFwb3AxOCIgaW5jbHV5ZSBhIHRvZG9zIGxvcyBwYcOtc2VzIGRlIGxhIHJvbmRhLgpQYXJhIGV4Y2x1aXIgYSBlc3RvcyBkb3MgcGHDrXNlcywgdGVuZW1vcyBxdWUgc2VsZWNjaW9uYXIgbG9zIHBhw61zZXMgcXVlIE5PIHNvbiBFRS5VVS4KeSBDYW5hZMOhLgpFc3RhIG51ZXZhIHNlbGVjY2nDs24gbGEgZ3VhcmRhbW9zIGVuIHVuIG51ZXZvIGRhdGFmcmFtZSBvIHNlIHB1ZWRlIHNvYnJlZXNjcmliaXIgZW4gZWwgZGF0YWZyYW1lIG9yaWdpbmFsLCBjb21vIHNlIGhhY2UgZW4gZXN0ZSBjYXNvIGRlYmlkbyBhIHF1ZSBsYSBleGNsdXNpw7NuIGRlIGVzdG9zIHBhw61zZXMgZXMgcGFyYSB0b2RvcyBsb3MgY8OhbGN1bG9zIHF1ZSBzaWd1ZW4uCkRlIGFjdWVyZG8gYWwgY3Vlc3Rpb25hcmlvLCBFRS5VVS4KdGllbmUgZWwgY8OzZGlnbyA0MCB5IENhbmFkw6EsIGVsIGPDs2RpZ28gNDEgZW4gbGEgdmFyaWFibGUgInBhaXMiLgpQYXJhIGV4Y2x1aXJsb3MgdGVuZW1vcyBxdWUgaW5jbHVpciBhIGxvcyBwYcOtc2VzIHF1ZSB0ZW5nYW4gdW4gY8OzZGlnbyBtZW5vciBhIDQwIChvIGRlIDM1IG8gbWVub3MpLgpQYXJhIGVzdG8gbnVldmFtZW50ZSBwb2RlbW9zIHVzYXIgZWwgY29tYW5kbyBgc3Vic2V0YC4KCmBgYHtyIGVsaW1pbmFyIFVTQSB5IENhbmFkYSAxOH0KbGFwb3AxOCA9IHN1YnNldChsYXBvcDE4LCBwYWlzPD0zNSkKYGBgCgpQb2RlbW9zIG9ic2VydmFyIGVuIGVsIEVudmlyb25tZW50IHF1ZSBzZSByZWR1Y2VuIGxhcyBvYnNlcnZhY2lvbmVzIGRlbCBkYXRhZnJhbWUgImxhcG9wMTgiIGx1ZWdvIGRlIGNvcnJlciBlc3RlIGPDs2RpZ28sIHB1ZXMgaGVtb3MgZWxpbWluYWRvIGxhcyBvYnNlcnZhY2lvbmVzIGRlIGVudHJldmlzdGFkb3MgZW4gZXN0b3MgZG9zIHBhw61zZXMuCkVsIG7Dum1lcm8gZGUgb2JzZXJ2YWNpb25lcyBwYXNhIGRlIDMxLDA1MCBhIDI4LDA0MiwgbsO6bWVybyBxdWUgY29pbmNpZGUgY29uIGVsIGRlIGxhIGJhc2UgZGUgZGF0b3MgZW4gZm9ybWF0byAuUkRhdGEgcXVlIG5vIGluY2x1w61hIGEgZXN0b3MgcGHDrXNlcy4KCkRlIGxhIG1pc21hIG1hbmVyYSBwb2RlbW9zIHByb2NlZGVyIGVuIGxhIGJhc2UgZGUgZGF0b3MgZGUgbGEgcm9uZGEgMjAyMSwgY29uIGxvIHF1ZSBkaXNtaW51eWVuIGxhcyBvYnNlcnZhY2lvbmVzIGEgNjA2NjEuCgpgYGB7ciBlbGltaW5hciBVU0EgeSBDYW5hZGEgMjF9CmxhcG9wMjEgPSBzdWJzZXQobGFwb3AyMSwgcGFpczw9MzUpCmBgYAoKIyBDYWxjdWxhciB1bmEgdmFyaWFibGUKClVuYSBwcsOhY3RpY2EgZnJlY3VlbnRlIGRlIExBUE9QIGNvbiBsb3MgZGF0b3MgZGVsIEJhcsOzbWV0cm8gZGUgbGFzIEFtw6lyaWNhcyBlcyBlbCByZS1lc2NhbGFtaWVudG8gZGUgdmFyaWFibGVzLgpFbCBjYXDDrXR1bG8gc29icmUgbGVnaXRpbWlkYWQgZGVtb2Nyw6F0aWNhIGRlbCByZXBvcnRlIGJyaW5kYSBlamVtcGxvcyBkZSBlc3RlIHJlLWVzY2FsYW1pZW50byBjb24gdmFyaWFibGVzIHJlbGFjaW9uYWRhcyBhbCBhcG95byBhbCBzaXN0ZW1hLgpQYXJhIGNhbGN1bGFyIGVzdGUgw61uZGljZSBkZSBhcG95byBhbCBzaXN0ZW1hIHNlIHRyYWJhamEgY29uIHVuIGNvbmp1bnRvIGRlIGNpbmNvIHZhcmlhYmxlczoKCkIxLgoqwr9IYXN0YSBxdcOpIHB1bnRvIGNyZWUgdXN0ZWQgcXVlIGxvcyB0cmlidW5hbGVzIGRlIGp1c3RpY2lhIGRlIChwYcOtcykgZ2FyYW50aXphbiB1biBqdWljaW8ganVzdG8/KgoKQjIuCirCv0hhc3RhIHF1w6kgcHVudG8gdGllbmUgdXN0ZWQgcmVzcGV0byBwb3IgbGFzIGluc3RpdHVjaW9uZXMgcG9sw610aWNhcyBkZSAocGHDrXMpPyoKCkIzLgoqwr9IYXN0YSBxdcOpIHB1bnRvIGNyZWUgdXN0ZWQgcXVlIGxvcyBkZXJlY2hvcyBiw6FzaWNvcyBkZWwgY2l1ZGFkYW5vIGVzdMOhbiBiaWVuIHByb3RlZ2lkb3MgcG9yIGVsIHNpc3RlbWEgcG9sw610aWNvIGRlIChwYcOtcyk/KgoKQjQuCirCv0hhc3RhIHF1w6kgcHVudG8gc2Ugc2llbnRlIG9yZ3VsbG9zbyBkZSB2aXZpciBiYWpvIGVsIHNpc3RlbWEgcG9sw610aWNvIGRlIChwYcOtcyk/KgoKQjYuCirCv0hhc3RhIHF1w6kgcHVudG8gcGllbnNhIHVzdGVkIHF1ZSBzZSBkZWJlIGFwb3lhciBhbCBzaXN0ZW1hIHBvbMOtdGljbyBkZSAocGHDrXMpPyoKCkNvbW8gaW5kaWNhIGVsIHJlcG9ydGUgIlBhcmEgY2FkYSBwcmVndW50YSwgbGEgZXNjYWxhIG9yaWdpbmFsIGRlIDEgKCJOYWRhIikgYSA3ICgiTXVjaG8iKSBzZSByZWNvZGlmaWNhIGVuIHVuYSBlc2NhbGEgZGUgMCBhIDEwMCwgZGUgdGFsIGZvcm1hIHF1ZSAwIGluZGljYSBlbCBtZW5vciBuaXZlbCBkZSBhcG95byBhbCBzaXN0ZW1hIHBvbMOtdGljbyB5IDEwMCBlcyBlbCBuaXZlbCBtw6F4aW1vIGRlIGFwb3lvIGFsIHNpc3RlbWEgcG9sw610aWNvLiBFc3RhIG51ZXZhIGVzY2FsYSBzaWd1ZSBsYSByZWNvZGlmaWNhY2nDs24gdMOtcGljYSBkZSBMQVBPUCB5IHB1ZWRlIHNlciBpbnRlcnByZXRhZGEgY29tbyB1bmEgbWVkaWNpw7NuIGRlbCBhcG95byBlbiB1bmlkYWRlcywgbyBncmFkb3MsIGVuIHVuYSBlc2NhbGEgY29udGludWEgcXVlIHZhIGRlIDAgYSAxMDAiIChwLjM0KS4KUGFyYSBjb21wcm9iYXIgbGEgZXNjYWxhIG9yaWdpbmFsIGRlIGVzdGFzIHZhcmlhYmxlcywgc2UgcHVlZGUgZGVzY3JpYmlyIGVzdGFzIHZhcmlhYmxlcyB1c2FuZG8gZWwgY29tYW5kbyBgdGFibGVgLgoKYGBge3IgZGVzY3JpYmlyfQp0YWJsZShsYXBvcDE4JGIxKQp0YWJsZShsYXBvcDE4JGIyKQp0YWJsZShsYXBvcDE4JGIzKQp0YWJsZShsYXBvcDE4JGI0KQp0YWJsZShsYXBvcDE4JGI2KQpgYGAKCk9ic2VydmFtb3MgcXVlIGVmZWN0aXZhbWVudGUgdG9kYXMgbGFzIHZhcmlhYmxlcyBlc3TDoW4gZW4gdW5hIGVzY2FsYSBkZSAxIGEgNy4KUGFyYSByZWVzY2FsYXIgdW5hIHZhcmlhYmxlIGVuIHVuYSBlc2NhbGEgb3JpZ2luYWwgZGUgMSBhIDcgYSBvdHJhIGRlIDAgYSAxMDAsIGxvIHByaW1lcm8gcXVlIHRlbmVtb3MgcXVlIGhhY2VyIGVzIHJlc3RhciAxIHVuaWRhZCwgY29uIGxvIHF1ZSBsYSB2YXJpYWJsZSB0ZW5kcsOtYSB1bmEgZXNjYWxhIGRlIDAgYSA2LCBsdWVnbyBkaXZpZGlybGEgZW50cmUgNiwgY29uIGxvIHF1ZSB2YXJpYXLDrWEgZW50cmUgMCB5IDEgeSwgZmluYWxtZW50ZSwgbXVsdGlwbGljYXJsYSBwb3IgMTAwLgpFc3RvIGVzOgoKVmFyaWFibGUgcmVlc2NhbGFkYSA9ICgodmFyaWFibGUgb3JpZ2luYWwgLTEpLzYpXCoxMDAKCmBgYHtyIGNhbGN1bGFyfQpsYXBvcDE4JGIxcmVjID0gKChsYXBvcDE4JGIxLTEpLzYpKjEwMApsYXBvcDE4JGIycmVjID0gKChsYXBvcDE4JGIyLTEpLzYpKjEwMApsYXBvcDE4JGIzcmVjID0gKChsYXBvcDE4JGIzLTEpLzYpKjEwMApsYXBvcDE4JGI0cmVjID0gKChsYXBvcDE4JGI0LTEpLzYpKjEwMApsYXBvcDE4JGI2cmVjID0gKChsYXBvcDE4JGI2LTEpLzYpKjEwMAp0YWJsZShsYXBvcDE4JGIxcmVjKQpgYGAKCkNvbiBlc3RhIHRyYW5zZm9ybWFjacOzbiBvYnNlcnZhbW9zIHF1ZSBsb3MgNCwwODkgZW50cmV2aXN0YWRvcyBxdWUgbWFyY2Fyb24gMSBlbiBsYSBwcmVndW50YSBCMSwgYWhvcmEgdGllbmVuIHVuIHB1bnRhamUgZGUgMC4KTG9zIDQsMDY3IHF1ZSBtYXJjYXJvbiAyLCBhaG9yYSB0aWVuZW4gdW4gcHVudGFqZSBkZSAxNi42NywgZXMgZGVjaXIgMi0xPTEvNj0wLjE2NjdcKjEwMD0xNi42Ny4KRXN0YSBtaXNtYSBvcGVyYWNpw7NuIHNlIHB1ZG8gaGFjZXIgY29uIGVsIGNvbWFuZG8gYGNhcjo6cmVjb2RlYCwgc2lndWllbmRvIGxhIHNpZ3VpZW50ZSByZWdsYSBkZSByZWNvZGlmaWNhY2nDs246CgotICAgVmFsb3IgZGUgMSBlbiB2YXJpYWJsZSBvcmlnaW5hbCBzZSByZWNvZGlmaWNhIGNvbW8gMCBlbiBudWV2YSB2YXJpYWJsZQotICAgVmFsb3IgZGUgMiBlbiB2YXJpYWJsZSBvcmlnaW5hbCBzZSByZWNvZGlmaWNhIGNvbW8gMTYuNjcgZW4gbnVldmEgdmFyaWFibGUKLSAgIFZhbG9yIGRlIDMgZW4gdmFyaWFibGUgb3JpZ2luYWwgc2UgcmVjb2RpZmljYSBjb21vIDMzLjMzIGVuIG51ZXZhIHZhcmlhYmxlCi0gICBWYWxvciBkZSA0IGVuIHZhcmlhYmxlIG9yaWdpbmFsIHNlIHJlY29kaWZpY2EgY29tbyA1MCBlbiBudWV2YSB2YXJpYWJsZQotICAgVmFsb3IgZGUgNSBlbiB2YXJpYWJsZSBvcmlnaW5hbCBzZSByZWNvZGlmaWNhIGNvbW8gNjYuNjcgZW4gbnVldmEgdmFyaWFibGUKLSAgIFZhbG9yIGRlIDYgZW4gdmFyaWFibGUgb3JpZ2luYWwgc2UgcmVjb2RpZmljYSBjb21vIDgzLjMzIGVuIG51ZXZhIHZhcmlhYmxlCi0gICBWYWxvciBkZSA3IGVuIHZhcmlhYmxlIG9yaWdpbmFsIHNlIHJlY29kaWZpY2EgY29tbyAxMDAgZW4gbnVldmEgdmFyaWFibGUKCkVzdGEgbWFuZXJhIGRlIHJlY29kaWZpY2FyLCBzaW4gZW1iYXJnbywgZXMgcG9jbyBlZmljaWVudGUuCkVzIG3DoXMgc2ltcGxlIHVzYXIgbGEgZsOzcm11bGEgcGFyYSBjYWxjdWxhciBsYSByZWNvZGlmaWNhY2nDs24uCgpQYXJhIGNhbGN1bGFyIGVsIMOtbmRpY2UgZGUgYXBveW8gYWwgc2lzdGVtYSwgZWwgcmVwb3J0ZSBpbmRpY2EgcXVlICJFbCDDrW5kaWNlIGRlIGFwb3lvIGFsIHNpc3RlbWEgZXMgZWwgcHJvbWVkaW8gZGUgY2luY28gcHJlZ3VudGFzOiBCMSwgQjIsIEIzLCBCNCB5IEI2IiAocC40NikuCkVzIGRlY2lyLCBjb24gbGFzIHZhcmlhYmxlcyByZWVzY2FsYWRhcyB0ZW5lbW9zIHF1ZSBjYWxjdWxhciBlbCBwcm9tZWRpbyBkZSBlc3RhcyBjaW5jbyB2YXJpYWJsZXMgcGFyYSBjYWRhIGluZGl2aWR1byAoZXMgZGVjaXIsIGVuIGNhZGEgZmlsYSBkZSBsYSBiYXNlIGRlIGRhdG9zKS4KUG9kcsOtYW1vcyBjYWxjdWxhciBlc3RhIG9wZXJhY2nDs24gZGVsIHByb21lZGlvIGRlIGZvcm1hIG1hbnVhbC4KCkFwb3lvIGFsIHNpc3RlbWEgPSAoYjFyZWMgKyBiMnJlYyArIGIzcmVjICsgYjRyZWMgKyBiNnJlYykvNQoKRW4gUiB0ZW5lbW9zIGVsIGNvbWFuZG8gYHJvd01lYW5zYCBxdWUgc2lydmEgcGFyYSBjYWxjdWxhciBwcm9tZWRpb3MgZGUgY2llcnRhcyBjb2x1bW5hcyBwb3IgY2FkYSBmaWxhLgpMYSBzaW50YXhpcyBgWywgODY6OTBdYCBpbmRpY2EgcXVlIHJlYWxpemFyZW1vcyBlbCBjw6FsY3VsbyBkZWwgcHJvbWVkaW8gcG9yIGZpbGFzIHBhcmEgdG9kYXMgbGFzIGZpbGFzIHkgdXNhbmRvIGxhcyBjb2x1bW5hcyA4NiBhIDkwIGRlbCBkYXRhZnJhbWUgImxhcG9wMTgiIChwb2Ryw61hbW9zIGhhY2VyIGVsIGPDoWxjdWxvIHBhcmEgYWxndW5hcyBmaWxhcyBlbiBwYXJ0aWN1bGFyIGRlZmluaWVuZG8gYFtmaWxhX246ZmlsYV9tLCA4Njo5MF1gKS4KRXN0ZSBwcm9tZWRpbyBsbyBndWFyZGFtb3MgZW4gdW5hIG51ZXZhIHZhcmlhYmxlICJhcG95byIsIHF1ZSBkZXNjcmliaW1vcy4KCmBgYHtyIGFwb3lvIGFsIHNpc3RlbWF9CmxhcG9wMTgkYXBveW8gPSByb3dNZWFucyhsYXBvcDE4Wyw4NTo4OV0pCnRhYmxlKGxhcG9wMTgkYXBveW8pCmBgYAoKQ29uIGVzdGUgw61uZGljZSBwb2RlbW9zIGNhbGN1bGFyIGVsIGFwb3lvIGFsIHNpc3RlbWEgcHJvbWVkaW8gcGFyYSBsYSDDumx0aW1hIHJvbmRhIGRlbCBCYXLDs21ldHJvIGRlIGxhcyBBbcOpcmljYXMsIGFzw60gY29tbyBsb3MgcHJvbWVkaW9zIGRlIGNhZGEgdW5hIGRlIGxhcyB2YXJpYWJsZXMgcXVlIGNvbXBvbmVuIGVsIMOtbmRpY2UuClVzYW1vcyBlbCBjb21hbmRvIGBtZWFuYCBwYXJhIGVsIHByb21lZGlvIHkgbGEgZXNwZWNpZmljYWNpw7NuIGBuYS5ybT1UYCBwYXJhIGluZGljYXJsZSBhbCBjb21hbmRvIHF1ZSBubyB0b21lIGVuIGN1ZW50YSBsb3MgdmFsb3JlcyBwZXJkaWRvcyBkZSBlc3RhcyB2YXJpYWJsZXMuClZlcmVtb3MgZXN0b3MgZXN0YWTDrXN0aWNvcyBlbiBtw6FzIGRldGFsbGUgZW4gb3RyYXMgc2VjY2lvbmVzLgoKYGBge3IgYXBveW8gYWwgc2lzdGVtYSAyMDE4LzE5fQptZWFuKGxhcG9wMTgkYXBveW8sIG5hLnJtPVQpCm1lYW4obGFwb3AxOCRiMXJlYywgbmEucm09VCkgI0NvcnRlcyBnYXJhbnRpemFuIGp1aWNpbyBqdXN0bwptZWFuKGxhcG9wMTgkYjJyZWMsIG5hLnJtPVQpICNSZXNwZXRvIGEgbGFzIGluc3RpdHVjaW9uZXMKbWVhbihsYXBvcDE4JGIzcmVjLCBuYS5ybT1UKSAjRGVyZWNob3MgYsOhc2ljb3MgZXN0w6FuIHByb3RlZ2lkb3MKbWVhbihsYXBvcDE4JGI0cmVjLCBuYS5ybT1UKSAjT3JndWxsb3MgcG9yIGVsIHNpc3RlbWEgcG9sw610aWNvCm1lYW4obGFwb3AxOCRiNnJlYywgbmEucm09VCkgI1NlIGRlYmVyw61hIGFwb3lhciBhbCBzaXN0ZW1hIHBvbMOtdGljbwpgYGAKCkVzdG9zIHJlc3VsdGFkb3Mgc29uIGxvcyBxdWUgc2UgbXVlc3RyYW4gZW4gZWwgR3LDoWZpY28gMi4xIHBhcmEgbGEgcm9uZGEgMjAxOC8xOS4KCiFbXShHcmFmMi4xLnBuZyl7d2lkdGg9IjYyOSJ9CgojIENhbGN1bGFyIHVuYSB2YXJpYWJsZSBkZSBtYW5lcmEgY29uZGljaW9uYWwKCkVuIGFsZ3VuYXMgb2Nhc2lvbmVzIGVsIGPDoWxjdWxvIGRlIHVuYSB2YXJpYWJsZSBubyByZXF1aWVyZSBzb2xhbWVudGUgbGEgdHJhbnNmb3JtYWNpw7NuIG51bcOpcmljYSBkZSBsYSB2YXJpYWJsZSBvcmlnaW5hbCwgc2lubyBxdWUgbG9zIHZhbG9yZXMgZGUgbGEgbnVldmEgdmFyaWFibGUgZGVwZW5kZW4gZGUgdmFsb3JlcyBkZSBvdHJhcyB2YXJpYWJsZXMuClBvciBlamVtcGxvLCBlbCBjYXDDrXR1bG8gIlJlZGVzIHNvY2lhbGVzIHkgYWN0aXR1ZGVzIHBvbMOtdGljYXMiIGRlbCByZXBvcnRlICJFbCBQdWxzbyBkZSBsYSBEZW1vY3JhY2lhIiBkZSBsYSByb25kYSAyMDE4LzE5IHByZXNlbnRhIGxvcyByZXN1bHRhZG9zIHBhcmEgbGFzIHZhcmlhYmxlcyAidXN1YXJpbyBkZSBXaGF0c2FwcCIsICJ1c3VhcmlvIGRlIFR3aXR0ZXIiIHkgInVzdWFyaW8gZGUgRmFjZWJvb2siLgpQYXJhIGNhbGN1bGFyIGVzdGFzIHZhcmlhYmxlcywgZWwgcGllIGRlIHDDoWdpbmEgNyBkZSBlc3RlIGNhcMOtdHVsbyBpbmRpY2E6ICJQYXJhIGNhZGEgcGxhdGFmb3JtYSwgc2UgaWRlbnRpZmljYW4gbG9zIHVzdWFyaW9zIGNvbiB1bmEgY29tYmluYWNpw7NuIGRlIGRvcyBjb25qdW50b3MgZGUgcHJlZ3VudGFzLiBQcmltZXJvLCBzZSBpZGVudGlmaWNhbiBjb21vIHVzdWFyaW9zIGEgcXVpZW5lcyByZXNwb25kZW4gcG9zaXRpdmFtZW50ZSBhIGxhcyBwcmVndW50YXMsIFNNRURJQTEvU01FRElBNC9TTUVESUE3LiDCv1RpZW5lIHVzdGVkIGN1ZW50YSBkZSBGYWNlYm9vay9Ud2l0dGVyL1doYXRzYXBwPyBMdWVnbywgc2UgcmVjb2RpZmljYSBjb21vIG5vIHVzdWFyaW8gYSBxdWllbmVzIHJlc3BvbmRlbiJudW5jYSIgYSBsYXMgcHJlZ3VudGFzIHNpZ3VpZW50ZXMsIFNNRURJQTIvU01FRElBNS9TTUVESUE4LiDCv0NvbiBxdcOpIGZyZWN1ZW5jaWEgdmUgY29udGVuaWRvIGVuIEZhY2Vib29rL1R3aXR0ZXIvV2hhdHNhcHA/IiAocC4gNjQpLgoKIVtdKHNtZWRpYS5wbmcpe3dpZHRoPSI0NjYifQoKRXMgZGVjaXIsIGVsIHVzdWFyaW8gbm8gc29sbyBlcyBlbCBxdWUgdGllbmUgdW5hIGN1ZW50YSAoU01FRElBMT0xKSwgc2lubyBlbCBxdWUgbGEgdXNhIGNvbiBjaWVydGEgZnJlY3VlbmNpYSAoU01FRElBMj0xLCAyLCAzLCA0KS4KRGUgZXN0YSBtYW5lcmEsIGVsIG5vIHVzdWFyaW8gcHVlZGUgdGVuZXIgdW5hIGN1ZW50YSwgcGVybyBudW5jYSB1c2FybGEuClBvciBsbyB0YW50bywgbGEgdmFyaWFibGUgInVzdWFyaW8iIGRlcGVuZGUgZGUgbG9zIHZhbG9yZXMgZGUgMiB2YXJpYWJsZXMuCkxhIHJlZ2xhIGRlIGNvZGlmaWNhY2nDs24gcXVlIHNlIHNpZ3VlIGVzOgoKLSAgIFVzdWFyaW8gZGUgRmFjZWJvb2sgPSAxIChzw60gZXMgdXN1YXJpbykgc2kgU01FRElBMSA9IDEgKHRpZW5lIGN1ZW50YSkgeSBTTUVESUEyIFw8PSA0IChsYSB1c2EgY29uIGFsZ3VuYSBmcmVjdWVuY2lhKQoKLSAgIFVzdWFyaW8gZGUgRmFjZWJvb2sgPSAwIChubyBlcyB1c3VhcmlvKSBzaSBTTUVESUEyID0gMiAobm8gdGllbmUgY3VlbnRhKSBvIFNNRURJQTIgPSA1ICh0aWVuZSBjdWVudGEgcGVybyBudW5jYSBsYSB1c2EpCgpQcm9kdWNpbW9zIGVzdGEgcmVnbGEgZGUgY29kaWZpY2FjacOzbiBjb24gbGEgc2lndWllbnRlIHNpbnRheGlzIGRlIFIsIHF1ZSB1c2EgZWwgY29tYW5kbyBgw6xmZWxzZWAuCkVzdGEgc2ludGF4aXMgaW5jbHV5ZSBsYSBjb25kaWNpw7NuIHBhcmEgYXNpZ25hciB2YWxvcmVzIGRlIDEgYSB1bmEgbnVldmEgdmFyaWFibGUgeSBhc2lnbmEgYSB0b2RhcyBsYXMgZGVtw6FzIG9ic2VydmFjaW9uZXMgZWwgdmFsb3IgZGUgMC4KRGVzY3JpYmltb3MgZXN0YXMgbnVldmFzIHZhcmlhYmxlcyB1c2FuZG8gbG9zIGNvbWFuZG9zIGB0YWJsZWAgcGFyYSBnZW5lcmFyIGxhcyBmcmVjdWVuY2lhcyBhYnNvbHV0YXMsIGBwcm9wLnRhYmxlYCBwYXJhIGxhcyBmcmVjdWVuY2lhcyByZWxhdGl2YXMgeSBgcm91bmRgIHBhcmEgcmVkb25kZWFyIGxvcyBkZWNpbWFsZXMuCkVzdG9zIGNvbWFuZG9zIGxvcyB2ZXJlbW9zIGVuIG3DoXMgZGV0YWxsZSBlbiBsYXMgc2lndWllbnRlcyBzZWNjaW9uZXMuCgpgYGB7ciB1c3VhcmlvcywgZWNobz1UUlVFLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsYXBvcDE4JGZiX3VzZXIgPSBpZmVsc2UobGFwb3AxOCRzbWVkaWExPT0xICYgbGFwb3AxOCRzbWVkaWEyPD00LCAxLCAwKQpsYXBvcDE4JHR3X3VzZXIgPSBpZmVsc2UobGFwb3AxOCRzbWVkaWE0PT0xICYgbGFwb3AxOCRzbWVkaWE1PD00LCAxLCAwKQpsYXBvcDE4JHdhX3VzZXIgPSBpZmVsc2UobGFwb3AxOCRzbWVkaWE3PT0xICYgbGFwb3AxOCRzbWVkaWE4PD00LCAxLCAwKQpyb3VuZChwcm9wLnRhYmxlKHRhYmxlKGxhcG9wMTgkZmJfdXNlcikpKjEwMCwgMSkKcm91bmQocHJvcC50YWJsZSh0YWJsZShsYXBvcDE4JHR3X3VzZXIpKSoxMDAsIDEpCnJvdW5kKHByb3AudGFibGUodGFibGUobGFwb3AxOCR3YV91c2VyKSkqMTAwLCAxKQpgYGAKCkVzdG9zIHJlc3VsdGFkb3Mgc29uIGxvcyBxdWUgc2UgcHJlc2VudGFuIGVuIGVsIEdyw6FmaWNvIDMuMSBkZWwgcmVwb3J0ZSBlbiBmb3JtYSBkZSBncsOhZmljb3MgY2lyY3VsYXJlcy4KVmVyZW1vcyBlc3RlIHRpcG8gZGUgZ3LDoWZpY29zIGVuIGxhIHNpZ3VpZW50ZSBzZWNjacOzbi4KCiFbXShHcmFmMy4xLnBuZyl7d2lkdGg9IjMyMyJ9CgojIE9ic2VydmFjacOzbiBkZWwgZWZlY3RvIGRlIGRpc2XDsW8KClRhbnRvIGxvcyByZXN1bHRhZG9zIHBhcmEgYXBveW8gYWwgc2lzdGVtYSwgY29tbyBsb3MgZGUgdXN1YXJpb3MgZGUgcmVkZXMgc29jaWFsZXMgZGlmaWVyZW4gZGUgbG9zIHF1ZSBhcGFyZWNlbiBlbiBlbCByZXBvcnRlIHBvciBkb3MgbW90aXZvcy4KRW4gcHJpbWVyIGx1Z2FyLCBwYXJhIGFwb3lvIGFsIHNpc3RlbWEsIGRlYmlkbyBhIHF1ZSAiTG9zIHZhbG9yZXMgYSBsbyBsYXJnbyBkZWwgdGllbXBvIHNlIGNhbGN1bGFuIGluY2x1eWVuZG8gw7puaWNhbWVudGUgbG9zIHBhw61zZXMgcXVlIGVsIEJhcsOzbWV0cm8gZGUgbGFzIEFtw6lyaWNhcyBoYSBlc3R1ZGlhZG8gcmVndWxhcm1lbnRlIGRlc2RlIDIwMDY6IEFyZ2VudGluYSwgQnJhc2lsLCBCb2xpdmlhLCBDaGlsZSwgQ29sb21iaWEsIENvc3RhIFJpY2EsIFJlcMO6YmxpY2EgRG9taW5pY2FuYSwgRWN1YWRvciwgRWwgU2FsdmFkb3IsIEd1YXRlbWFsYSwgSG9uZHVyYXMsIEphbWFpY2EsIE3DqXhpY28sIE5pY2FyYWd1YSwgUGFuYW3DoSwgUGFyYWd1YXksIFBlcsO6LCBVcnVndWF5IiAocC40NikuCkVsIGPDs2RpZ28gc29sbyBmaWx0cmEgbGEgw7psdGltYSByb25kYSwgcXVlIGluY2x1eWUgcGHDrXNlcyBxdWUgbm8gZXN0w6FuIGVuIGVzYSBsaXN0YSwgY29tbyBFc3RhZG9zIFVuaWRvcyBvIENhbmFkw6EuCkRlIG90cm8gbGFkbywgbG9zIGPDoWxjdWxvcyByZXBvcnRhZG9zIGVuIGxhIHB1YmxpY2FjacOzbiBpbmNsdXllbiBlbCB1c28gZGUgZmFjdG9yZXMgZGUgcG9uZGVyYWNpw7NuLCBxdWUgbm8gaGVtb3MgaW5jbHVpZG8gZW4gZXN0b3MgY8OhbGN1bG9zLCBwZXJvIHF1ZSBlbiBvdHJvcyBkb2N1bWVudG9zIGluY29ycG9yYXJlbW9zICh2ZXIgW2FxdcOtXShodHRwczovL3JwdWJzLmNvbS9hcnR1cm9fbWFsZG9uYWRvLzcyODYyNikpLgoKIyBSZXN1bWVuCgpFbiBlc3RlIGRvY3VtZW50byBoZW1vcyB2aXN0byBsb3MgZWxlbWVudG9zIGLDoXNpY29zIGRlIGxhIG1hbmlwdWxhY2nDs24geSB0cmFuc2Zvcm1hY2nDs24gZGUgZGF0b3MgdXNhbmRvIGVsIEJhcsOzbWV0cm8gZGUgbGFzIEFtw6lyaWNhcy4KSGVtb3MgcmVjb2RpZmljYWRvIHVuYSB2YXJpYWJsZSB1c2FuZG8gZWwgY29tYW5kbyBgcmVjb2RlYCwgaGVtb3Mgc2VsZWNjaW9uYWRvIGNhc29zIHVzYW5kbyBgc3Vic2V0YCB5IGhlbW9zIGNhbGN1bGFkbyB1bmEgbnVldmEgdmFyaWFibGUgYWxnZWJyYWljYW1lbnRlIHkgY29uIGVsIGNvbWFuZG8gYGlmZWxzZWAuCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("Manipulacion.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
